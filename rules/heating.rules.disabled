// ===============================
//   OpenHAB Heating Control Rules
// ===============================

// --- Timers for 120min Comfort Heating ---
var Timer bathroomTimer = null
var Timer kitchenTimer = null

// ===============================
//   Generic Heating Decision Logic
// ===============================

/*
 * shouldHeat:
 * Decides if heating should be ON or OFF based on temperature and switch state.
 * Sends commands to the radiator and Heating_ToWarm item.
 * Returns true if heating should be ON, false otherwise.
 */
val Functions$Function6<GenericItem, GenericItem, NumberItem, NumberItem, Number, String, Boolean> shouldHeat = [
    heatingSwitch, radiator, tempNow, temp2h, tempLimit, label |
    if (heatingSwitch.state == ON) {
        logInfo("heating", label + " ON - evaluating temperature...")
        logInfo("heating", "Temp now: " + tempNow.state.toString + ", in 2h: " + temp2h.state.toString)
        if ((tempNow.state as QuantityType<Temperature>) < tempLimit &&
            (temp2h.state as QuantityType<Temperature>) < (tempLimit + 1|°C)) {
            logInfo("heating", label + ": cold enough → COMFORT")
            radiator.sendCommand("COMFORT")
            Heating_ToWarm.sendCommand(OFF)
        } else {
            logInfo("heating", label + ": too warm → OFF")
            radiator.sendCommand("OFF")
            Heating_ToWarm.sendCommand(ON)
        }
        true
    } else {
        logInfo("heating", label + " OFF - switching OFF radiator")
        radiator.sendCommand("OFF")
        Heating_ToWarm.sendCommand(OFF)
        false
    }
]

// ===============================
//   Generic 120min Comfort Heating
// ===============================

/*
 * comfort120min:
 * Starts 120min comfort heating if shouldHeat returns true.
 * Always switches off after 120min.
 * NOTE: Pass shouldHeat as argument due to DSL lambda context!
 */
val Functions$Function7<GenericItem, GenericItem, NumberItem, NumberItem, Number, Boolean, Functions$Function6<GenericItem, GenericItem, NumberItem, NumberItem, Number, String, Boolean>, Object> comfort120min = [
    heatingSwitch, radiator, tempNow, temp2h, tempLimit, alwaysOff, shouldHeatFn |
    logInfo("heating", "Uhhhh: I am in the function - REALLY")
    var Timer timer = null
    var String label = ""

    if (radiator.name == "FRITZDECT3011Badezimmer_RadiatorMode") {
        timer = bathroomTimer
        label = "Badezimmer"
    } else if (radiator.name == "FRITZDECT3011Kueche_RadiatorMode") {
        timer = kitchenTimer
        label = "Küche"
    }

    logInfo("heating", "Calling - should heat now.... ")

    val shouldStart = shouldHeatFn.apply(
        heatingSwitch, radiator, tempNow, temp2h, tempLimit, label
    )

    if (shouldStart) {
        if (timer !== null) timer.cancel()
        if (radiator.name == "FRITZDECT3011Badezimmer_RadiatorMode") {
            val finalLabel = label
            bathroomTimer = createTimer(now.plusMinutes(120))[|
                logInfo("heating", finalLabel + " 120min timer ended → OFF")
                radiator.sendCommand("OFF")
                bathroomTimer = null
            ]
        } else if (radiator.name == "FRITZDECT3011Kueche_RadiatorMode") {
            val finalLabel = label
            kitchenTimer = createTimer(now.plusMinutes(120))[|
                logInfo("heating", finalLabel + " 120min timer ended → OFF")
                radiator.sendCommand("OFF")
                kitchenTimer = null
            ]
        }
    } else {
        radiator.sendCommand("OFF")
        if (radiator.name == "FRITZDECT3011Badezimmer_RadiatorMode") {
            if (bathroomTimer !== null) {
                bathroomTimer.cancel()
                bathroomTimer = null
            }
        } else if (radiator.name == "FRITZDECT3011Kueche_RadiatorMode") {
            if (kitchenTimer !== null) {
                kitchenTimer.cancel()
                kitchenTimer = null
            }
        }
    }
]

// ===============================
//   Room Heating Rules
// ===============================

// --- Arbeitszimmer ---
rule "Heating Arbeitszimmer"
when
    Item Heating_Arbeitszimmer_Comfort changed
then
    shouldHeat.apply(
        Heating_Arbeitszimmer_Comfort,
        FRITZDECT3011Arbeitszimmer_RadiatorMode,
        localCurrentTemperature,
        localCurrentTemperature_2h,
        22|°C,
        "Arbeitszimmer"
    )
end

// --- Küche ---
rule "Heating Kueche"
when
    Item Heating_Kueche_Comfort changed
then
    shouldHeat.apply(
        Heating_Kueche_Comfort,
        FRITZDECT3011Kueche_RadiatorMode,
        localCurrentTemperature,
        localCurrentTemperature_2h,
        20|°C,
        "Küche"
    )
end

// --- Badezimmer ---
rule "Heating Badezimmer"
when
    Item Heating_Badezimmer_Comfort changed
then
    shouldHeat.apply(
        Heating_Badezimmer_Comfort,
        FRITZDECT3011Badezimmer_RadiatorMode,
        localCurrentTemperature,
        localCurrentTemperature_2h,
        21|°C,
        "Badezimmer"
    )
end

// ===============================
//   120min Comfort Heating Rules
// ===============================

// --- Badezimmer 120min ---
rule "Heating Badezimmer 120min"
when
    Item Heating_Badezimmer_Comfort_120min received update
then
    comfort120min.apply(
        Heating_Badezimmer_Comfort_120min,
        FRITZDECT3011Badezimmer_RadiatorMode,
        localCurrentTemperature,
        localCurrentTemperature_2h,
        18|°C,
        true, // alwaysOff: always switch off after 120min
        shouldHeat
    )
end

// --- Küche 120min ---
rule "Heating Kueche 120min"
when
    Item Heating_Kueche_Comfort_120min received update
then
    logInfo("heating", "Update Heating Küche - now calling the lambda")
    comfort120min.apply(
        Heating_Kueche_Comfort_120min,
        FRITZDECT3011Kueche_RadiatorMode,
        localCurrentTemperature,
        localCurrentTemperature_2h,
        12|°C,
        true, // alwaysOff: always switch off after 120min
        shouldHeat
    )
end

// ===============================
//   Presence Control (Christian)
// ===============================

rule "Heating - When Christian comes home"
when
    Item CNOut changed
then
    if (CNOut.state == ON) {
        logInfo("heating", "Christian left → Heating OFF")
        Heating_Arbeitszimmer_Comfort.sendCommand(OFF)
    } else {
        val hour = now.getHour
        if (hour > 7 && hour <= 22) {
            logInfo("heating", "Christian returns → Heating ON")
            Heating_Arbeitszimmer_Comfort.sendCommand(ON)
        } else {
            logInfo("heating", "Christian returns, but it's night → no heating")
        }
    }
end

rule "Heating - Christian is out"
when
    Item CNOut changed
then
    if (CNOut.state == ON) {
        Heating_Kueche_Comfort.sendCommand(OFF)
        Heating_Badezimmer_Comfort.sendCommand(OFF)
        logInfo("heating", "Christian out → Küche + Bad OFF")
    }
end

// ===============================
//   Scheduled Heating Rules
// ===============================

rule "Heating - Night Mode"
when
    Time cron "0 0 23-01 * * ? *"
then
    Heating_Arbeitszimmer_Comfort.sendCommand(OFF)
    Heating_Kueche_Comfort.sendCommand(OFF)
    Heating_Badezimmer_Comfort.sendCommand(OFF)
    logInfo("heating", "Night mode → Arbeitszimmer OFF")
end

rule "Heating Weekend - Morning"
when
    Time cron "0 0 11 ? * SAT,SUN *"
then
    if (CNOut.state == OFF) {
        Heating_Arbeitszimmer_Comfort.sendCommand(ON)
        logInfo("heating", "Weekend morning → Arbeitszimmer ON")
    }
end

rule "Heating Kueche - Night Mode"
when
    Time cron "0 0 20 * * ? *"
then
    Heating_Kueche_Comfort.sendCommand(OFF)
    logInfo("heating", "Night mode → Küche OFF")
end

rule "Heating - Good Morning (Weekend)"
when
    Time cron "0 45 8 ? * SAT,SUN *"
then
    if (CNOut.state == OFF) {
        Heating_Arbeitszimmer_Comfort.sendCommand(ON)
        Heating_Kueche_Comfort_120min.sendCommand(ON)
        Heating_Badezimmer_Comfort_120min.sendCommand(ON)
        logInfo("heating", "Good morning weekend → Küche + BAD + Arbeitszimmer ON")
    }
end

rule "Heating Kueche - Lunch"
when
    Time cron "0 0 12 * * ? *"
then
    if (CNOut.state == OFF) {
        Heating_Kueche_Comfort_120min.sendCommand(ON)
        logInfo("heating", "Lunch → Küche ON")
    }
end

rule "Heating Kueche - Dinner"
when
    Time cron "0 0 18 * * ? *"
then
    if (CNOut.state == OFF || ANOut.state == OFF) {
        Heating_Kueche_Comfort_120min.sendCommand(ON)
        logInfo("heating", "Dinner → Küche ON")
    } else {
        logInfo("heating", "Dinner → Nobody home")
    }
end

// ===============================
//   End of Heating Rules
// ===============================