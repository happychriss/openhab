// ===============================
//   OpenHAB Heating Control Rules
// ===============================

// --- Timers for 120min Comfort Heating ---
var Timer bathroomTimer = null
var Timer kitchenTimer = null

// --- Manual Override Flags (runtime only, no persistence) ---
var Boolean bathroomManualOverride = false
var Boolean kitchenManualOverride = false

// ===============================
//   Generic Heating Decision Logic
// ===============================

/*
 * shouldHeat:
 * Decides if heating should be ON or OFF based on temperature and switch state.
 * Sends commands to the radiator and Heating_ToWarm item.
 * Returns true if heating should be ON, false otherwise.
 */
val Functions$Function6<GenericItem, GenericItem, NumberItem, NumberItem, Number, String, Boolean> shouldHeat = [
    heatingSwitch, radiator, tempNow, temp2h, tempLimit, label |
    if (heatingSwitch.state == ON) {
        logInfo("heating", label + " ON - evaluating temperature...")
        logInfo("heating", "Temp now: " + tempNow.state.toString + ", in 2h: " + temp2h.state.toString)
        if ((tempNow.state as QuantityType<Temperature>) < tempLimit &&
            (temp2h.state as QuantityType<Temperature>) < (tempLimit + 1|°C)) {
            logInfo("heating", label + ": cold enough → COMFORT")
            radiator.sendCommand("COMFORT")
            Heating_ToWarm.sendCommand(OFF)
        } else {
            logInfo("heating", label + ": too warm → OFF")
            radiator.sendCommand("OFF")
            Heating_ToWarm.sendCommand(ON)
        }
        true
    } else {
        logInfo("heating", label + " OFF - switching OFF radiator")
        radiator.sendCommand("OFF")
        Heating_ToWarm.sendCommand(OFF)
        false
    }
]

// ===============================
//   Generic 120min Comfort Heating
// ===============================

/*
 * comfort120min:
 * Starts 120min comfort heating if shouldHeat returns true.
 * If alwaysOff is true, always switches off after 120min.
 * If alwaysOff is false, checks for manual override (runtime only).
 * Uses global variables for timer and manual override.
 */
val Functions$Function6<GenericItem, GenericItem, NumberItem, NumberItem, Number, Boolean, Void> comfort120min = [
    heatingSwitch, radiator, tempNow, temp2h, tempLimit, alwaysOff |

    // Determine which timer and override flag to use
    var Timer timer = null
    var String label = ""

    if (radiator.name == "FRITZDECT3011Badezimmer_RadiatorMode") {
        timer = bathroomTimer
        label = "Badezimmer"
        bathroomManualOverride = false
    } else if (radiator.name == "FRITZDECT3011Kueche_RadiatorMode") {
        timer = kitchenTimer
        label = "Küche"
        kitchenManualOverride = false
    }

    val shouldStart = shouldHeat.apply(
        heatingSwitch, radiator, tempNow, temp2h, tempLimit, label
    )

    if (shouldStart) {
        if (timer !== null) timer.cancel()
        if (radiator.name == "FRITZDECT3011Badezimmer_RadiatorMode") {
            bathroomTimer = createTimer(now.plusMinutes(120))[|
                if (alwaysOff || !bathroomManualOverride) {
                    logInfo("heating", label + " 120min timer ended → OFF")
                    radiator.sendCommand("OFF")
                } else {
                    logInfo("heating", label + " 120min timer ended, manual override detected → KEEP STATE")
                }
                bathroomTimer = null
                bathroomManualOverride = false
            ]
        } else if (radiator.name == "FRITZDECT3011Kueche_RadiatorMode") {
            kitchenTimer = createTimer(now.plusMinutes(120))[|
                if (alwaysOff || !kitchenManualOverride) {
                    logInfo("heating", label + " 120min timer ended → OFF")
                    radiator.sendCommand("OFF")
                } else {
                    logInfo("heating", label + " 120min timer ended, manual override detected → KEEP STATE")
                }
                kitchenTimer = null
                kitchenManualOverride = false
            ]
        }
    } else {
        radiator.sendCommand("OFF")
        if (radiator.name == "FRITZDECT3011Badezimmer_RadiatorMode") {
            if (bathroomTimer !== null) {
                bathroomTimer.cancel()
                bathroomTimer = null
            }
            bathroomManualOverride = false
        } else if (radiator.name == "FRITZDECT3011Kueche_RadiatorMode") {
            if (kitchenTimer !== null) {
                kitchenTimer.cancel()
                kitchenTimer = null
            }
            kitchenManualOverride = false
        }
    }
]

// ===============================
//   Room Heating Rules
// ===============================

// --- Arbeitszimmer ---
rule "Heating Arbeitszimmer"
when
    Item Heating_Arbeitszimmer_Comfort changed
then
    shouldHeat.apply(
        Heating_Arbeitszimmer_Comfort,
        FRITZDECT3011Arbeitszimmer_RadiatorMode,
        localCurrentTemperature,
        localCurrentTemperature_2h,
        22|°C,
        "Arbeitszimmer"
    )
end

// --- Küche ---
rule "Heating Kueche"
when
    Item Heating_Kueche_Comfort changed
then
    shouldHeat.apply(
        Heating_Kueche_Comfort,
        FRITZDECT3011Kueche_RadiatorMode,
        localCurrentTemperature,
        localCurrentTemperature_2h,
        20|°C,
        "Küche"
    )
end

// --- Badezimmer ---
rule "Heating Badezimmer"
when
    Item Heating_Badezimmer_Comfort changed
then
    shouldHeat.apply(
        Heating_Badezimmer_Comfort,
        FRITZDECT3011Badezimmer_RadiatorMode,
        localCurrentTemperature,
        localCurrentTemperature_2h,
        21|°C,
        "Badezimmer"
    )
end

// ===============================
//   120min Comfort Heating Rules
// ===============================

// --- Badezimmer 120min ---
rule "Heating Badezimmer 120min"
when
    Item Heating_Badezimmer_Comfort_120min received update
then
    comfort120min.apply(
        Heating_Badezimmer_Comfort_120min,
        FRITZDECT3011Badezimmer_RadiatorMode,
        localCurrentTemperature,
        localCurrentTemperature_2h,
        18|°C,
        false // alwaysOff: false = allow manual override
    )
end

// --- Küche 120min ---
rule "Heating Kueche 120min"
when
    Item Heating_Kueche_Comfort_120min received update
then
    comfort120min.apply(
        Heating_Kueche_Comfort_120min,
        FRITZDECT3011Kueche_RadiatorMode,
        localCurrentTemperature,
        localCurrentTemperature_2h,
        12|°C,
        true // alwaysOff: true = always switch off after 120min
    )
end

// ===============================
//   Manual Override Detection
// ===============================

/*
 * Detects manual override (any command except "COMFORT" or "OFF" during 120min timer).
 * Sets the manualOverride flag for the respective radiator.
 */

// Badezimmer manual override
rule "Manual Override Badezimmer"
when
    Item FRITZDECT3011Badezimmer_RadiatorMode received command
then
    if (bathroomTimer !== null && receivedCommand != "COMFORT" && receivedCommand != "OFF") {
        bathroomManualOverride = true
        logInfo("heating", "Manual override detected for Badezimmer")
    }
end

// Küche manual override
rule "Manual Override Kueche"
when
    Item FRITZDECT3011Kueche_RadiatorMode received command
then
    if (kitchenTimer !== null && receivedCommand != "COMFORT" && receivedCommand != "OFF") {
        kitchenManualOverride = true
        logInfo("heating", "Manual override detected for Küche")
    }
end


// ===============================
//   Presence Control (Christian)
// ===============================

rule "Heating - When Christian comes home"
when
    Item CNOut changed
then
    if (CNOut.state == ON) {
        logInfo("heating", "Christian left → Heating OFF")
        Heating_Arbeitszimmer_Comfort.sendCommand(OFF)
    } else {
        val hour = now.getHour
        if (hour > 7 && hour <= 22) {
            logInfo("heating", "Christian returns → Heating ON")
            Heating_Arbeitszimmer_Comfort.sendCommand(ON)
        } else {
            logInfo("heating", "Christian returns, but it's night → no heating")
        }
    }
end

rule "Heating - Christian is out"
when
    Item CNOut changed
then
    if (CNOut.state == ON) {
        Heating_Kueche_Comfort.sendCommand(OFF)
        Heating_Badezimmer_Comfort.sendCommand(OFF)
        logInfo("heating", "Christian out → Küche + Bad OFF")
    }
end

// ===============================
//   Scheduled Heating Rules
// ===============================

rule "Heating - Night Mode"
when
    Time cron "0 0 23-01 * * ? *"
then
    Heating_Arbeitszimmer_Comfort.sendCommand(OFF)
    Heating_Kueche_Comfort.sendCommand(OFF)
    Heating_Badezimmer_Comfort.sendCommand(OFF)
    logInfo("heating", "Night mode → Arbeitszimmer OFF")
end

rule "Heating Weekend - Morning"
when
    Time cron "0 0 11 ? * SAT,SUN *"
then
    if (CNOut.state == OFF) {
        Heating_Arbeitszimmer_Comfort.sendCommand(ON)
        logInfo("heating", "Weekend morning → Arbeitszimmer ON")
    }
end

rule "Heating Kueche - Night Mode"
when
    Time cron "0 0 20 * * ? *"
then
    Heating_Kueche_Comfort.sendCommand(OFF)
    logInfo("heating", "Night mode → Küche OFF")
end

rule "Heating - Good Morning (Weekend)"
when
    Time cron "0 45 8 ? * SAT,SUN *"
then
    if (CNOut.state == OFF) {
        Heating_Arbeitszimmer_Comfort.sendCommand(ON)
        Heating_Kueche_Comfort_120min.sendCommand(ON)
        Heating_Badezimmer_Comfort_120min.sendCommand(ON)
        logInfo("heating", "Good morning weekend → Küche + BAD + Arbeitszimmer ON")
    }
end

rule "Heating Kueche - Lunch"
when
    Time cron "0 0 12 * * ? *"
then
    if (CNOut.state == OFF) {
        Heating_Kueche_Comfort_120min.sendCommand(ON)
        logInfo("heating", "Lunch → Küche ON")
    }
end

rule "Heating Kueche - Dinner"
when
    Time cron "0 0 18 * * ? *"
then
    if (CNOut.state == OFF || ANOut.state == OFF) {
        Heating_Kueche_Comfort_120min.sendCommand(ON)
        logInfo("heating", "Dinner → Küche ON")
    } else {
        logInfo("heating", "Dinner → Nobody home")
    }
end

// ===============================
//   End of Heating Rules
// ===============================